use std::str::FromStr;

use crate::engine::core::dsl::ast_raw::{
	VarID,
	TypeID,
	Immediate,
	Literal,
	Expression,
	BinOp,
	BinOps,
	VarDecl,
	FuncDecl,
	FuncParam,
	FuncCall,
	FuncArg,
	FuncSignature,
	Statement,
	Conditional,
	Place,
	Assign,
	Block,
	GenericList,
	ObjectDecl,
	ObjectDeclContents,
	ObjectProperty,
	TypeIdentifier,
	new_binop,
	};

grammar;

match {
    "let",
	"obj",
	"if",
	"else",
    ":",
    "=",
	"==",
	"->",
	"fn",
	"<",
	"<=",
	">",
	">=",
    ";",
	"(",
	")",
	"{",
	"}",
	"#",
	"`",
	"*",
	"-",
	"+",
	",",
	".",
	"[]",
	"true",
	"false",
	"return",
    "Number", "Rank", "Suit", "Zone", "Player",
    // Rank Literals
    "Ace", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King",
    // Suit Literals
    "Hearts", "Diamonds", "Clubs", "Spades",
    // Other terminals
    r"[a-zA-Z_][a-zA-Z0-9_]*" => Identifier, // Variable names
    r"-?\d+" => NumberString,                // Integer literals
    r#""([^"\\]|\\.)*""# => StringLiteral,     // String literals
	
    r"\s*" => { },
}



RankString: &'input str = {
    "Ace",
    "Two",
    "Three",
    "Four",
    "Five",
    "Six",
    "Seven",
    "Eight",
    "Nine",
    "Ten",
    "Jack",
    "Queen",
    "King",
};

SuitString: &'input str = {
	"Hearts",
	"Diamonds",
	"Clubs",
	"Spades",
}

pub NumberLiteral : Literal = NumberString => Literal::Number(String::from(<>));

pub RankLiteral : Literal = {
	<s:RankString> => Literal::RankLiteral(String::from(s)),
}

pub SuitLiteral : Literal = {
	<s:SuitString> => Literal::SuitLiteral(String::from(s)),
}

pub BooleanLiteral : Literal = {
	"true" => Literal::BooleanLiteral(String::from(<>)),
	"false" => Literal::BooleanLiteral(String::from(<>)),
}

pub ZoneLiteral : Literal = {
	"#" <s:IdentifierString> "#" => Literal::ZoneLiteral(<>),
}

pub PlayerLiteral : Literal = {
	"`" <s:IdentifierString> "`" => Literal::PlayerLiteral(<>),
}

pub Literal : Literal = {
	NumberLiteral => <>,
	RankLiteral => <>,
	SuitLiteral => <>,
	BooleanLiteral => <>,
	ZoneLiteral => <>,
	PlayerLiteral => <>,
}

pub Expression : Expression = CompExpr;

CompExpr: Expression = {
	<l:CompExpr> "==" <r:AddiExpr> => new_binop(l, BinOps::Equal, r),
	<l:CompExpr> ">" <r:AddiExpr> => new_binop(l, BinOps::GreaterThan, r),
	<l:CompExpr> ">=" <r:AddiExpr> => new_binop(l, BinOps::GreaterEqual, r),
	<l:CompExpr> "<" <r:AddiExpr> => new_binop(l, BinOps::LesserThan, r),
	<l:CompExpr> "<=" <r:AddiExpr> => new_binop(l, BinOps::LesserEqual, r),
	AddiExpr,
}

AddiExpr : Expression = {
	<l:AddiExpr> "+" <r:MultExpr> => new_binop(l, BinOps::Add, r),
	<l:AddiExpr> "-" <r:MultExpr> => new_binop(l, BinOps::Subtract, r),
	MultExpr,
}

MultExpr : Expression = {
	<l:MultExpr> "*" <r:AtomExpr> => new_binop(l, BinOps::Multiply, r),
	AtomExpr,
}

pub AtomExpr : Expression = {
	"(" <e:Expression> ")" => e,
	Literal => Expression::Imm(<>),
	Place => Expression::Var(<>),
	FuncCall => Expression::FuncCall(<>),
}

pub Statement : Statement = {
	<b:Block> ";" => Statement::Block(b),
	VarDecl => Statement::Decl(<>),
	Assign => Statement::Assign(<>),
	Conditional => Statement::Conditional(<>),
	ObjectDecl => Statement::ObjectDecl(<>),
	"return" ";" => Statement::Return,
}

DeclType : TypeIdentifier = {
	":" <t:TypeIdentifier> => t,
}

DeclValue : Expression = {
	"=" <e: Expression> => e,
}

pub VarDecl : VarDecl = {
	"let" <i:IdentifierString> <p:DeclType?> <init : DeclValue?> ";" => VarDecl { var_type: p, var_name : i, value : init },
}

pub FuncParam : FuncParam = {
	<name:IdentifierString> <t:DeclType> <init: DeclValue?> => FuncParam {var_type : t, var_name : name, value : init},
}


pub FuncReturn : TypeIdentifier = {
	"->" <t: TypeIdentifier> => t,
}

pub FuncDecl : FuncDecl = {
	"fn" <name: IdentifierString> <generics: GenericList> "(" <params: CommaList<FuncParam>?>  ")" <ret: FuncReturn?> <contents: Block> ";"=> {
		FuncDecl { name, generics, arguments : params.unwrap_or_else(|| Vec::new()), return_type : ret, body: contents }
	},
}

pub FuncArg : FuncArg = {
	<param : IdentifierString> "=" <e : Expression> => FuncArg { param_name : Some(param), value : e },
	<Expression> => FuncArg { param_name : None, value : <> },
}

pub FuncCall : FuncCall =  {
	<name : IdentifierString> "(" <args : CommaList<FuncArg>? > ")" ";" => FuncCall { name, arguments : args.unwrap_or(Vec::new()) },
}

pub Assign : Assign = {
	<p:Place> "=" <e:Expression> ";" => Assign { from : e, to: p},
}

pub Conditional : Conditional = {
	"if" <e:Expression> <t:Block> <f : ("else" <Block>)?>";" => Conditional { condition : e, exec_if : t, exec_else : f },
}

pub Block : Block = {
	"{" <l:StatementList> "}" => Block { instructions : l},
	"{" "}" => { 
		let empty : Vec<Statement> = Vec::new();
		Block { instructions : empty }
	},
}

pub ObjectDecl : ObjectDecl = {
	"obj" <name: IdentifierString> <gl: GenericList> <contents : ObjectDeclContents> ";" => ObjectDecl {name, generics : gl, contents : contents}
}

pub ObjectDeclContents : ObjectDeclContents = {
	"{" <o:InnerObjectDecl> "}" ";" => o,
	"{" "}" ";" => ObjectDeclContents { properties : Vec::new(), methods : Vec::new() },
}

pub ObjectProperty : ObjectProperty = {
	<name: IdentifierString> ":" <t: TypeIdentifier> => ObjectProperty { object_type : t, name},
}

InnerObjectDecl : ObjectDeclContents = {
	ObjectProperty => ObjectDeclContents { properties : Vec::from([<>]), methods : Vec::new() },
	FuncDecl => ObjectDeclContents { properties : Vec::new(), methods : Vec::from([<>]) },
	<i: InnerObjectDecl> <o: ObjectProperty> => {let mut inner = i; inner.properties.push(o); inner },
	<i: InnerObjectDecl> <f: FuncDecl> => {let mut inner = i; inner.methods.push(f); inner },
}

pub Place : Place = {
	IdentifierList => Place { location : <> },
}

pub IdentifierList : Vec<String> = {
	Identifier => Vec::from([String::from(<>)]),
	<l: IdentifierList> "." <i: Identifier> => {let mut vec = l; vec.push(String::from(i)); vec},
}

pub TypeIdentifier : TypeIdentifier = {
	<p: Place> "[]" => TypeIdentifier::Array(p),
	<Place> => TypeIdentifier::Regular(<>),

}

pub IdentifierString : String = {
	Identifier => String::from(<>),
}

pub StatementList : Vec<Statement> = {

	Statement => Vec::from([<>]),
	<l : StatementList> <s : Statement> => {let mut vec = l; vec.push(s); vec},
}

pub GenericList : GenericList = {
	<gl: ("<" <InnerGenericList> ">")?> => gl,
}


pub InnerGenericList : Vec<String> = {
	Identifier => Vec::from([String::from(<>)]),
	<l: InnerGenericList> "," <g: Identifier> => {let mut vec = l; vec.push(String::from(g)); vec},
}


CommaList<T> : Vec<T> = {
	T => Vec::from([<>]),
	<mut l: CommaList<T>> "," <e: T> => {
		l.push(e);
		l
	}
}
